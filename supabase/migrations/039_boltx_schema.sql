-- ============================================================================
-- BoltX AI Schema
-- ============================================================================
-- Creates tables and functions for BoltX AI-powered optimizations
-- Features: AI insights, predictions, optimizations, user profiles, interventions

-- ============================================================================
-- AI Insights Table
-- ============================================================================
-- Stores insights generated by AI (OpenAI GPT-4 or similar)
CREATE TABLE IF NOT EXISTS analytics.ai_insights (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  customer_id UUID NOT NULL REFERENCES customer.accounts(id) ON DELETE CASCADE,
  category TEXT NOT NULL,
  title TEXT NOT NULL,
  description TEXT NOT NULL,
  impact TEXT NOT NULL,
  recommendations JSONB DEFAULT '[]'::jsonb,
  metadata JSONB DEFAULT '{}'::jsonb,
  generated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  
  CONSTRAINT ai_insights_category_check CHECK (category IN ('revenue', 'conversion', 'ux', 'security')),
  CONSTRAINT ai_insights_impact_check CHECK (impact IN ('high', 'medium', 'low'))
);

-- Indexes for AI insights
CREATE INDEX IF NOT EXISTS idx_ai_insights_customer_id ON analytics.ai_insights(customer_id);
CREATE INDEX IF NOT EXISTS idx_ai_insights_category ON analytics.ai_insights(category);
CREATE INDEX IF NOT EXISTS idx_ai_insights_impact ON analytics.ai_insights(impact);
CREATE INDEX IF NOT EXISTS idx_ai_insights_generated_at ON analytics.ai_insights(generated_at DESC);
CREATE INDEX IF NOT EXISTS idx_ai_insights_customer_category ON analytics.ai_insights(customer_id, category);

-- ============================================================================
-- AI Predictions Table
-- ============================================================================
-- Stores predictions for abandonment, conversion, etc.
CREATE TABLE IF NOT EXISTS analytics.ai_predictions (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  customer_id UUID NOT NULL REFERENCES customer.accounts(id) ON DELETE CASCADE,
  session_id TEXT NOT NULL,
  order_form_id TEXT,
  prediction_type TEXT NOT NULL DEFAULT 'abandonment',
  risk_score INTEGER NOT NULL CHECK (risk_score >= 0 AND risk_score <= 100),
  risk_level TEXT NOT NULL,
  confidence DECIMAL(3,2) NOT NULL DEFAULT 0.5 CHECK (confidence >= 0 AND confidence <= 1),
  factors JSONB NOT NULL DEFAULT '{}'::jsonb,
  recommendations JSONB DEFAULT '[]'::jsonb,
  intervention_suggested BOOLEAN DEFAULT FALSE,
  intervention_type TEXT,
  metadata JSONB DEFAULT '{}'::jsonb,
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  
  CONSTRAINT ai_predictions_type_check CHECK (prediction_type IN ('abandonment', 'conversion', 'friction')),
  CONSTRAINT ai_predictions_risk_level_check CHECK (risk_level IN ('low', 'medium', 'high', 'critical')),
  CONSTRAINT ai_predictions_intervention_type_check CHECK (intervention_type IS NULL OR intervention_type IN ('discount', 'security', 'simplify', 'progress'))
);

-- Indexes for AI predictions
CREATE INDEX IF NOT EXISTS idx_ai_predictions_customer_id ON analytics.ai_predictions(customer_id);
CREATE INDEX IF NOT EXISTS idx_ai_predictions_session_id ON analytics.ai_predictions(session_id);
CREATE INDEX IF NOT EXISTS idx_ai_predictions_order_form_id ON analytics.ai_predictions(order_form_id);
CREATE INDEX IF NOT EXISTS idx_ai_predictions_type ON analytics.ai_predictions(prediction_type);
CREATE INDEX IF NOT EXISTS idx_ai_predictions_risk_level ON analytics.ai_predictions(risk_level);
CREATE INDEX IF NOT EXISTS idx_ai_predictions_created_at ON analytics.ai_predictions(created_at DESC);
CREATE INDEX IF NOT EXISTS idx_ai_predictions_session_created ON analytics.ai_predictions(session_id, created_at DESC);

-- ============================================================================
-- User Profiles Table
-- ============================================================================
-- Stores user profiles for personalization
CREATE TABLE IF NOT EXISTS analytics.user_profiles (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  customer_id UUID NOT NULL REFERENCES customer.accounts(id) ON DELETE CASCADE,
  session_id TEXT NOT NULL,
  device_type TEXT,
  browser TEXT,
  location JSONB DEFAULT '{}'::jsonb,
  behavior JSONB DEFAULT '{}'::jsonb,
  preferences JSONB DEFAULT '{}'::jsonb,
  inferred_intent JSONB DEFAULT '{}'::jsonb,
  metadata JSONB DEFAULT '{}'::jsonb,
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  
  CONSTRAINT user_profiles_device_type_check CHECK (device_type IS NULL OR device_type IN ('mobile', 'desktop', 'tablet'))
);

-- Indexes for user profiles
CREATE INDEX IF NOT EXISTS idx_user_profiles_customer_id ON analytics.user_profiles(customer_id);
CREATE INDEX IF NOT EXISTS idx_user_profiles_session_id ON analytics.user_profiles(session_id);
CREATE INDEX IF NOT EXISTS idx_user_profiles_updated_at ON analytics.user_profiles(updated_at DESC);
CREATE UNIQUE INDEX IF NOT EXISTS idx_user_profiles_session_unique ON analytics.user_profiles(session_id);

-- ============================================================================
-- AI Optimizations Table
-- ============================================================================
-- Tracks optimizations applied (A/B tests, form optimizations, etc.)
CREATE TABLE IF NOT EXISTS analytics.ai_optimizations (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  customer_id UUID NOT NULL REFERENCES customer.accounts(id) ON DELETE CASCADE,
  optimization_type TEXT NOT NULL,
  name TEXT NOT NULL,
  description TEXT,
  config JSONB NOT NULL DEFAULT '{}'::jsonb,
  status TEXT NOT NULL DEFAULT 'active',
  metrics JSONB DEFAULT '{}'::jsonb,
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  started_at TIMESTAMPTZ,
  completed_at TIMESTAMPTZ,
  
  CONSTRAINT ai_optimizations_type_check CHECK (optimization_type IN ('form', 'layout', 'content', 'flow')),
  CONSTRAINT ai_optimizations_status_check CHECK (status IN ('active', 'paused', 'completed', 'archived'))
);

-- Indexes for AI optimizations
CREATE INDEX IF NOT EXISTS idx_ai_optimizations_customer_id ON analytics.ai_optimizations(customer_id);
CREATE INDEX IF NOT EXISTS idx_ai_optimizations_type ON analytics.ai_optimizations(optimization_type);
CREATE INDEX IF NOT EXISTS idx_ai_optimizations_status ON analytics.ai_optimizations(status);
CREATE INDEX IF NOT EXISTS idx_ai_optimizations_created_at ON analytics.ai_optimizations(created_at DESC);
CREATE INDEX IF NOT EXISTS idx_ai_optimizations_customer_status ON analytics.ai_optimizations(customer_id, status);

-- ============================================================================
-- AI Interventions Table
-- ============================================================================
-- Tracks interventions applied (discounts, messages, etc.)
CREATE TABLE IF NOT EXISTS analytics.ai_interventions (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  customer_id UUID NOT NULL REFERENCES customer.accounts(id) ON DELETE CASCADE,
  session_id TEXT NOT NULL,
  order_form_id TEXT,
  intervention_type TEXT NOT NULL,
  risk_score INTEGER NOT NULL CHECK (risk_score >= 0 AND risk_score <= 100),
  risk_level TEXT NOT NULL,
  applied BOOLEAN DEFAULT FALSE,
  applied_at TIMESTAMPTZ,
  result TEXT,
  metadata JSONB DEFAULT '{}'::jsonb,
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  
  CONSTRAINT ai_interventions_type_check CHECK (intervention_type IN ('discount', 'security', 'simplify', 'progress')),
  CONSTRAINT ai_interventions_risk_level_check CHECK (risk_level IN ('low', 'medium', 'high', 'critical')),
  CONSTRAINT ai_interventions_result_check CHECK (result IS NULL OR result IN ('converted', 'abandoned', 'pending'))
);

-- Indexes for AI interventions
CREATE INDEX IF NOT EXISTS idx_ai_interventions_customer_id ON analytics.ai_interventions(customer_id);
CREATE INDEX IF NOT EXISTS idx_ai_interventions_session_id ON analytics.ai_interventions(session_id);
CREATE INDEX IF NOT EXISTS idx_ai_interventions_order_form_id ON analytics.ai_interventions(order_form_id);
CREATE INDEX IF NOT EXISTS idx_ai_interventions_type ON analytics.ai_interventions(intervention_type);
CREATE INDEX IF NOT EXISTS idx_ai_interventions_risk_level ON analytics.ai_interventions(risk_level);
CREATE INDEX IF NOT EXISTS idx_ai_interventions_applied ON analytics.ai_interventions(applied);
CREATE INDEX IF NOT EXISTS idx_ai_interventions_result ON analytics.ai_interventions(result);
CREATE INDEX IF NOT EXISTS idx_ai_interventions_created_at ON analytics.ai_interventions(created_at DESC);

-- ============================================================================
-- RLS Policies (if needed)
-- ============================================================================
-- Note: RLS is handled at the analytics schema level
-- These tables inherit the analytics schema permissions

-- ============================================================================
-- Functions
-- ============================================================================

-- Function to update user profile
CREATE OR REPLACE FUNCTION analytics.update_user_profile(
  p_session_id TEXT,
  p_customer_id UUID,
  p_device_type TEXT DEFAULT NULL,
  p_browser TEXT DEFAULT NULL,
  p_location JSONB DEFAULT NULL,
  p_behavior JSONB DEFAULT NULL,
  p_preferences JSONB DEFAULT NULL,
  p_inferred_intent JSONB DEFAULT NULL
)
RETURNS UUID AS $$
DECLARE
  v_profile_id UUID;
BEGIN
  INSERT INTO analytics.user_profiles (
    customer_id,
    session_id,
    device_type,
    browser,
    location,
    behavior,
    preferences,
    inferred_intent,
    updated_at
  )
  VALUES (
    p_customer_id,
    p_session_id,
    p_device_type,
    p_browser,
    COALESCE(p_location, '{}'::jsonb),
    COALESCE(p_behavior, '{}'::jsonb),
    COALESCE(p_preferences, '{}'::jsonb),
    COALESCE(p_inferred_intent, '{}'::jsonb),
    NOW()
  )
  ON CONFLICT (session_id) DO UPDATE SET
    device_type = COALESCE(p_device_type, user_profiles.device_type),
    browser = COALESCE(p_browser, user_profiles.browser),
    location = COALESCE(p_location, user_profiles.location),
    behavior = COALESCE(p_behavior, user_profiles.behavior),
    preferences = COALESCE(p_preferences, user_profiles.preferences),
    inferred_intent = COALESCE(p_inferred_intent, user_profiles.inferred_intent),
    updated_at = NOW()
  RETURNING id INTO v_profile_id;
  
  RETURN v_profile_id;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Function to insert AI prediction
CREATE OR REPLACE FUNCTION analytics.insert_ai_prediction(
  p_customer_id UUID,
  p_session_id TEXT,
  p_risk_score INTEGER,
  p_risk_level TEXT,
  p_order_form_id TEXT DEFAULT NULL,
  p_prediction_type TEXT DEFAULT 'abandonment',
  p_confidence DECIMAL DEFAULT 0.5,
  p_factors JSONB DEFAULT '{}'::jsonb,
  p_recommendations JSONB DEFAULT '[]'::jsonb,
  p_intervention_suggested BOOLEAN DEFAULT FALSE,
  p_intervention_type TEXT DEFAULT NULL
)
RETURNS UUID AS $$
DECLARE
  v_prediction_id UUID;
BEGIN
  INSERT INTO analytics.ai_predictions (
    customer_id,
    session_id,
    order_form_id,
    prediction_type,
    risk_score,
    risk_level,
    confidence,
    factors,
    recommendations,
    intervention_suggested,
    intervention_type
  )
  VALUES (
    p_customer_id,
    p_session_id,
    p_order_form_id,
    p_prediction_type,
    p_risk_score,
    p_risk_level,
    p_confidence,
    COALESCE(p_factors, '{}'::jsonb),
    COALESCE(p_recommendations, '[]'::jsonb),
    p_intervention_suggested,
    p_intervention_type
  )
  RETURNING id INTO v_prediction_id;
  
  RETURN v_prediction_id;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Function to insert AI intervention
CREATE OR REPLACE FUNCTION analytics.insert_ai_intervention(
  p_customer_id UUID,
  p_session_id TEXT,
  p_intervention_type TEXT,
  p_risk_score INTEGER,
  p_risk_level TEXT,
  p_order_form_id TEXT DEFAULT NULL,
  p_metadata JSONB DEFAULT '{}'::jsonb
)
RETURNS UUID AS $$
DECLARE
  v_intervention_id UUID;
BEGIN
  INSERT INTO analytics.ai_interventions (
    customer_id,
    session_id,
    order_form_id,
    intervention_type,
    risk_score,
    risk_level,
    metadata
  )
  VALUES (
    p_customer_id,
    p_session_id,
    p_order_form_id,
    p_intervention_type,
    p_risk_score,
    p_risk_level,
    COALESCE(p_metadata, '{}'::jsonb)
  )
  RETURNING id INTO v_intervention_id;
  
  RETURN v_intervention_id;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Function to get latest prediction for session
CREATE OR REPLACE FUNCTION analytics.get_latest_prediction(
  p_session_id TEXT
)
RETURNS TABLE (
  id UUID,
  customer_id UUID,
  session_id TEXT,
  order_form_id TEXT,
  prediction_type TEXT,
  risk_score INTEGER,
  risk_level TEXT,
  confidence DECIMAL,
  factors JSONB,
  recommendations JSONB,
  intervention_suggested BOOLEAN,
  intervention_type TEXT,
  created_at TIMESTAMPTZ
) AS $$
BEGIN
  RETURN QUERY
  SELECT
    p.id,
    p.customer_id,
    p.session_id,
    p.order_form_id,
    p.prediction_type,
    p.risk_score,
    p.risk_level,
    p.confidence,
    p.factors,
    p.recommendations,
    p.intervention_suggested,
    p.intervention_type,
    p.created_at
  FROM analytics.ai_predictions p
  WHERE p.session_id = p_session_id
  ORDER BY p.created_at DESC
  LIMIT 1;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- ============================================================================
-- Comments
-- ============================================================================
COMMENT ON TABLE analytics.ai_insights IS 'AI-generated insights for checkout optimization';
COMMENT ON TABLE analytics.ai_predictions IS 'ML predictions for abandonment, conversion, etc.';
COMMENT ON TABLE analytics.user_profiles IS 'User profiles for personalization';
COMMENT ON TABLE analytics.ai_optimizations IS 'Applied optimizations and A/B tests';
COMMENT ON TABLE analytics.ai_interventions IS 'Interventions applied to prevent abandonment';

